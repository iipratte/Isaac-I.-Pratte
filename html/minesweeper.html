<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Minesweeper</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      margin: 20px;
    }
    h1 {
      margin-bottom: 10px;
    }
    /* Use inline-grid so the container sizes exactly to its content. */
    #game {
      display: inline-grid;
      grid-template-columns: repeat(16, 30px);
      gap: 1px;
      border: 2px solid #444;
      background-color: #444;
      margin: 0 auto;
    }
    .cell {
      width: 30px;
      height: 30px;
      background-color: #ccc;
      border: 1px solid #888;
      text-align: center;
      line-height: 30px;
      font-weight: bold;
      cursor: pointer;
      user-select: none;
    }
    .cell.revealed {
      background-color: #e0e0e0;
      cursor: default;
      border: 1px solid #aaa;
    }
    #controls {
      margin-top: 20px;
    }
    button {
      font-size: 16px;
      padding: 8px 16px;
      cursor: pointer;
    }
    #message {
      font-size: 18px;
      color: green;
      margin-top: 10px;
    }
  </style>
    <link rel="icon" type="image/x-icon" href="../images/iip-logo.png">
    <link rel="stylesheet" type="text/css"  href="../styles/styles.css">
</head>
<body>

<!-- Header and Navigation combined -->
<div id="top" class="common header">
    
    <div class="header-container">
        <!-- Header -->
        <a class="header-name" href="#">Isaac I. Pratte</a>

        <!-- Navigation -->
        <div class="nav-bar">
            <a class="navigation" href="about.html">About</a>
            <a class="navigation" href="adventures.html">Adventures</a>
            <a class="navigation" href="#">Minesweeper</a>
            <a class="navigation" href="resume.html">Resume</a>
            
            <a class="navigation" href="https://www.linkedin.com/in/iipratte/" target="_blank">LinkedIn</a>
        </div>
    </div>
</div><br>

<h1 class="common pagetitle">MINESWEEPER</h1><br><br>
<p>The following is entirely AI generated.</p><br><br>
<br>


  <div id="game"></div>
  <div id="controls">
    <button id="resetButton">Reset</button>
    <p id="message"></p>
  </div>
  <script>
    const gridSize = 16;
    const numMines = 40;
    // Traditional Minesweeper colors.
    const numberColors = {
      1: "#0000FF", // blue
      2: "#008200", // green
      3: "#FF0000", // red
      4: "#000084", // dark blue
      5: "#840000", // maroon
      6: "#008284", // turquoise
      7: "#000000", // black
      8: "#808080"  // gray
    };
    let board = [];
    let firstClick = true;
    let gameOver = false;

    const gameContainer = document.getElementById('game');
    const messageEl = document.getElementById('message');
    const resetButton = document.getElementById('resetButton');

    // Create the board: instantiate cells and add them to the grid.
    function createBoard() {
      board = [];
      gameContainer.innerHTML = '';
      for (let i = 0; i < gridSize; i++) {
        board[i] = [];
        for (let j = 0; j < gridSize; j++) {
          board[i][j] = {
            mine: false,
            revealed: false,
            flagged: false,
            neighbor: 0,
            element: null
          };
          const cell = document.createElement('div');
          cell.classList.add('cell');
          cell.setAttribute('data-row', i);
          cell.setAttribute('data-col', j);
          // Left-click: reveal cell or trigger chording.
          cell.addEventListener('click', cellClick);
          // Right-click: toggle flag.
          cell.addEventListener('contextmenu', cellRightClick);
          gameContainer.appendChild(cell);
          board[i][j].element = cell;
        }
      }
    }

    // Place mines after the first click ensuring the clicked cell is safe.
    function placeMines(excludeRow, excludeCol) {
      let minesPlaced = 0;
      while (minesPlaced < numMines) {
        const row = Math.floor(Math.random() * gridSize);
        const col = Math.floor(Math.random() * gridSize);
        if (row === excludeRow && col === excludeCol) continue;
        if (board[row][col].mine) continue;
        board[row][col].mine = true;
        minesPlaced++;
      }
      // Calculate neighbor mine counts.
      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          board[i][j].neighbor = countNeighborMines(i, j);
        }
      }
    }

    // Count adjacent mines.
    function countNeighborMines(row, col) {
      let count = 0;
      for (let i = -1; i <= 1; i++) {
        for (let j = -1; j <= 1; j++) {
          if (i === 0 && j === 0) continue;
          const r = row + i;
          const c = col + j;
          if (r >= 0 && r < gridSize && c >= 0 && c < gridSize) {
            if (board[r][c].mine) count++;
          }
        }
      }
      return count;
    }

    // Handle left-click events.
    function cellClick(e) {
      if (gameOver) return;
      const cell = e.target;
      const row = parseInt(cell.getAttribute('data-row'));
      const col = parseInt(cell.getAttribute('data-col'));
      const cellData = board[row][col];

      // Chording: if a revealed numbered cell is clicked and 
      // the count of adjacent flagged cells equals the number, reveal neighbors.
      if (cellData.revealed && cellData.neighbor > 0) {
        let flaggedCount = 0;
        for (let i = -1; i <= 1; i++) {
          for (let j = -1; j <= 1; j++) {
            const r = row + i;
            const c = col + j;
            if (r >= 0 && r < gridSize && c >= 0 && c < gridSize) {
              if (board[r][c].flagged) flaggedCount++;
            }
          }
        }
        if (flaggedCount === cellData.neighbor) {
          for (let i = -1; i <= 1; i++) {
            for (let j = -1; j <= 1; j++) {
              const r = row + i;
              const c = col + j;
              if (r >= 0 && r < gridSize && c >= 0 && c < gridSize) {
                if (!board[r][c].revealed && !board[r][c].flagged) {
                  revealCell(r, c);
                }
              }
            }
          }
          checkWin();
        }
        return;
      }

      if (cellData.revealed) return;

      // Place mines on the first click.
      if (firstClick) {
        firstClick = false;
        placeMines(row, col);
      }
      revealCell(row, col);
      checkWin();
    }

    // Reveal a cell, recursively revealing neighbors if there are no adjacent mines.
    function revealCell(row, col) {
      const cellData = board[row][col];
      const cellElement = cellData.element;
      if (cellData.revealed || cellData.flagged) return;
      cellData.revealed = true;
      cellElement.classList.add('revealed');

      if (cellData.mine) {
        cellElement.textContent = 'ðŸ’£';
        gameOver = true;
        messageEl.textContent = 'Game Over!';
        revealAllMines();
        return;
      }

      if (cellData.neighbor > 0) {
        cellElement.textContent = cellData.neighbor;
        cellElement.style.color = numberColors[cellData.neighbor];
      } else {
        cellElement.textContent = '';
        for (let i = -1; i <= 1; i++) {
          for (let j = -1; j <= 1; j++) {
            const r = row + i;
            const c = col + j;
            if (r >= 0 && r < gridSize && c >= 0 && c < gridSize) {
              revealCell(r, c);
            }
          }
        }
      }
    }

    // Handle right-click to toggle flags.
    function cellRightClick(e) {
      e.preventDefault();
      if (gameOver) return;
      const cell = e.target;
      const row = parseInt(cell.getAttribute('data-row'));
      const col = parseInt(cell.getAttribute('data-col'));
      const cellData = board[row][col];
      if (cellData.revealed) return;
      cellData.flagged = !cellData.flagged;
      cell.textContent = cellData.flagged ? 'ðŸš©' : '';
      checkWin();
    }

    // Reveal all mines when the game is lost.
    function revealAllMines() {
      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          if (board[i][j].mine) {
            board[i][j].element.classList.add('revealed');
            board[i][j].element.textContent = 'ðŸ’£';
          }
        }
      }
    }

    // Check if win conditions are met.
    function checkWin() {
      let flaggedCount = 0;
      let correctFlags = 0;
      let allSafeRevealed = true;
      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          const cellData = board[i][j];
          if (cellData.flagged) {
            flaggedCount++;
            if (cellData.mine) correctFlags++;
          }
          if (!cellData.revealed && !cellData.mine) {
            allSafeRevealed = false;
          }
        }
      }
      if ((flaggedCount === numMines && correctFlags === numMines) || allSafeRevealed) {
        gameOver = true;
        messageEl.textContent = 'Congratulations! You won!';
      }
    }

    // Reset the game.
    function resetGame() {
      firstClick = true;
      gameOver = false;
      messageEl.textContent = '';
      createBoard();
    }

    resetButton.addEventListener('click', resetGame);
    createBoard();
  </script>
</body>
</html>
